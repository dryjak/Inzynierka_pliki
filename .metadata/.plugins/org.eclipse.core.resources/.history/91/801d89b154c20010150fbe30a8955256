/*
 * MPU6050.c
 *
 *  Created on: Sep 6, 2025
 *      Author: jakub
 */

#include "MPU6050.h"
#include "main.h"
#include "math.h"

// Functions used to read angles
static uint8_t Read8(MPU6050_t *MPU6050, uint8_t Register);
static MPU6050_STATE_t Write8(MPU6050_t *MPU6050, uint8_t Register, uint8_t Value);
static int16_t Read16(MPU6050_t *MPU6050, uint8_t Register);

static MPU6050_STATE_t MPU6050_SetGyroRange(MPU6050_t *MPU6050);
static MPU6050_STATE_t MPU6050_SetAccelerationRange(MPU6050_t *MPU6050);

static MPU6050_STATE_t MPU6050_ReadAccelerationRaw(MPU6050_t *MPU6050, DataRaw_t *AccelRaw);
static MPU6050_STATE_t MPU6050_ReadAcceleration(MPU6050_t *MPU6050, Data_t *Accelerations);
static MPU6050_STATE_t MPU6050_CalibrateAccel(MPU6050_t *MPU6050);

static MPU6050_STATE_t MPU6050_ReadGyroRaw(MPU6050_t *MPU6050, DataRaw_t *GyroRaw);
static MPU6050_STATE_t MPU6050_ReadGyro(MPU6050_t *MPU6050, Data_t *GyroCalculated);
static MPU6050_STATE_t MPU6050_CalibrateGyro(MPU6050_t *MPU6050);

static MPU6050_STATE_t MPU6050_SetDigitalLowPassFilter(MPU6050_t *MPU6050);

static void ComplementaryFilter(float *roll, float *pitch, float roll_accel, float pitch_accel);



//Initialize MPU6050
MPU6050_STATE_t MPU6050_Init(MPU6050_t *MPU6050, I2C_HandleTypeDef *Hi2c, uint16_t Address)
{
    uint8_t CheckID;

    MPU6050->hi2c     = Hi2c;
    MPU6050->address  = Address;

    CheckID = Read8(MPU6050, 0x75);
    if (CheckID != 0x68) 										//Checking IMU ID
    {
        return MPU6050_ERROR;
    }

    if (MPU6050_WakeUp(MPU6050) != MPU6050_OK) 					//Waking up the IMU
    {
        return MPU6050_ERROR;
    }
    if (MPU6050_SetAccelerationRange(MPU6050) != MPU6050_OK) 	//Setting acceleration range
    {
        return MPU6050_ERROR;
    }
    if (MPU6050_SetGyroRange(MPU6050) != MPU6050_OK) 			//Setting gyro range
    {
        return MPU6050_ERROR;
    }

    MPU6050->AccelOffset.X = 0.0f;
    MPU6050->AccelOffset.Y = 0.0f;
    MPU6050->AccelOffset.Z = 0.0f;
    MPU6050->GyroOffset.X  = 0.0f;
    MPU6050->GyroOffset.Y  = 0.0f;
    MPU6050->GyroOffset.Z  = 0.0f;

    MPU6050_CalibrateAccel(MPU6050);		//Getting data to calibrate accel
    MPU6050_CalibrateGyro(MPU6050);			//Getting data to calibrate gyro

    //level device and take first measurement
    //MPU6050_DegFromAccel(MPU6050, &MPU6050->FirstMeasure.X, &MPU6050->FirstMeasure.Y);

    return MPU6050_OK;
}

uint8_t MPU6050_WHO_AM_I (MPU6050_t *MPU6050) 	//Checking ID before working with IMU
{
    return Read8(MPU6050, 0x75);
}

MPU6050_STATE_t MPU6050_WakeUp(MPU6050_t *MPU6050)
{
    uint8_t Value = Read8(MPU6050, PWR_MGMT_1);

    Value &= ~(1 << 6);  // disable sleep
    Value &= ~(1 << 5);  // disable cycle
    Value |= (1 << 3);   // disable temp sensor

    return Write8(MPU6050, PWR_MGMT_1, Value);
}

//Calculating angles from accelerometr data
MPU6050_STATE_t MPU6050_DegFromAccel(MPU6050_t *MPU6050, float *Roll, float *Pitch)
{
    Data_t Accel;
    MPU6050_ReadAcceleration(MPU6050, &Accel);

    // Poprawione obliczenia:
    *Roll  = atan2f(Accel.Y, Accel.Z) * 180.0f / M_PI;
    *Pitch = atan2f(-Accel.X, sqrtf(Accel.Y*Accel.Y + Accel.Z*Accel.Z)) * 180.0f / M_PI;

    return MPU6050_OK;
}
//Calculating angles from gyro data
MPU6050_STATE_t MPU6050_DegFromGyro(MPU6050_t *MPU6050, float *RollG, float *PitchG, float *YawG)
{
    Data_t Gyro;
    MPU6050_ReadGyro(MPU6050, &Gyro);

    static uint32_t LastTick = 0;
    uint32_t TimeNow = HAL_GetTick();

    if(LastTick == 0)
    {
    	//init
    	LastTick = TimeNow;
    	return MPU6050_OK;
    }

    float dt = (float)(TimeNow - LastTick) / 1000;	//ms -> s
    LastTick = TimeNow;

    *RollG  += (Gyro.X) * dt;
    *PitchG += (Gyro.Y) * dt;
    *YawG   += (Gyro.Z) * dt;

    return MPU6050_OK;
}

//Calculating and combining data form accelerometr and gyro
MPU6050_STATE_t MPU6050_Angle(MPU6050_t *MPU6050, float *Roll, float *Pitch, float *Yaw)
{
    float RollAccel, PitchAccel;

    //Accel
    MPU6050_DegFromAccel(MPU6050, &RollAccel, &PitchAccel);

    static uint8_t initialized = 0;
    if (!initialized)
    {
        *Roll = RollAccel;
        *Pitch = PitchAccel;
        *Yaw = 0.0f;
        initialized = 1;

        MPU6050_DegFromGyro(MPU6050, Roll, Pitch, Yaw);
        return MPU6050_OK;
    }

    //Gyro
    MPU6050_DegFromGyro(MPU6050, Roll, Pitch, Yaw);

    //Filter
    //const float alpha = 0.9f;
    //*Roll  = alpha * (*Roll)  + (1.0f - alpha) * RollAccel;
    //*Pitch = alpha * (*Pitch) + (1.0f - alpha) * RollAccel;

    ComplementaryFilter(Roll, Pitch, RollAccel, PitchAccel);


    return MPU6050_OK;
}
//filter functions
static void ComplementaryFilter(float *roll, float *pitch, float roll_accel, float pitch_accel)
{
    const float alpha = 0.98f;
    *roll  = alpha * (*roll)  + (1.0f - alpha) * roll_accel;
    *pitch = alpha * (*pitch) + (1.0f - alpha) * pitch_accel;
}

//Help functions
static uint8_t Read8(MPU6050_t *MPU6050, uint8_t Register)
{
    uint8_t Value;
    HAL_I2C_Mem_Read(MPU6050->hi2c, (MPU6050->address) << 1, Register, 1, &Value, 1, MPU6050_TIMEOUT);
    return Value;
}

static MPU6050_STATE_t Write8(MPU6050_t *MPU6050, uint8_t Register, uint8_t Value)
{
    return HAL_I2C_Mem_Write(MPU6050->hi2c, (MPU6050->address) << 1, Register, 1, &Value, 1, MPU6050_TIMEOUT);
}

static int16_t Read16(MPU6050_t *MPU6050, uint8_t Register)
{
    uint8_t Value[2];
    HAL_I2C_Mem_Read(MPU6050->hi2c, (MPU6050->address) << 1, Register, 1, Value, 2, MPU6050_TIMEOUT);
    return (int16_t)((Value[0] << 8) | Value[1]);
}

static MPU6050_STATE_t MPU6050_SetGyroRange(MPU6050_t *MPU6050)
{
    uint8_t RegisterValue = Read8(MPU6050, GYRO_CONFIG);
    RegisterValue &= ~( (1 << 4) | (1 << 5) ); // ±250°/s
    return Write8(MPU6050, GYRO_CONFIG, RegisterValue);
}

static MPU6050_STATE_t MPU6050_SetAccelerationRange(MPU6050_t *MPU6050)
{
    uint8_t RegisterValue = Read8(MPU6050, ACCEL_CONFIG);
    RegisterValue &= ~( (1 << 4) | (1 << 5) ); // ±2g
    return Write8(MPU6050, ACCEL_CONFIG, RegisterValue);
}
static MPU6050_STATE_t MPU6050_SetDigitalLowPassFilter(MPU6050_t *MPU6050)
{
	uint8_t RegisterValue = Read8(MPU6050, CONFIG);
	RegisterValue |= (( 1 << 0) ); //184Hz (Accel) and 188Hz (Gyro)
}

// --- surowe i skalowane odczyty Accel/Gyro (prywatne) ---

static MPU6050_STATE_t MPU6050_ReadAccelerationRaw(MPU6050_t *MPU6050, DataRaw_t *AccelRaw)
{
    uint8_t buf[6] = {0};
    if (HAL_I2C_Mem_Read(MPU6050->hi2c, (MPU6050->address)<<1, ACCEL_XOUT_H, 1, buf, 6, MPU6050_TIMEOUT) != HAL_OK)
    {
        return MPU6050_ERROR;
    }

    AccelRaw->X = (int16_t)((buf[0] << 8) | buf[1]);
    AccelRaw->Y = (int16_t)((buf[2] << 8) | buf[3]);
    AccelRaw->Z = (int16_t)((buf[4] << 8) | buf[5]);
    return MPU6050_OK;
}

static MPU6050_STATE_t MPU6050_ReadAcceleration(MPU6050_t *MPU6050, Data_t *Accelerations)
{
    DataRaw_t Raw;
    MPU6050_ReadAccelerationRaw(MPU6050, &Raw);

    const float ScaleFactor = 16384.0f; // ±2g

    Accelerations->X = (float)(Raw.X - MPU6050->AccelOffset.X) / ScaleFactor;
    Accelerations->Y = (float)(Raw.Y - MPU6050->AccelOffset.Y) / ScaleFactor;
    Accelerations->Z = (float)(Raw.Z - MPU6050->AccelOffset.Z) / ScaleFactor;

    MPU6050->AccelTest.X = Accelerations->X;
    MPU6050->AccelTest.Y = Accelerations->Y;
    MPU6050->AccelTest.Z = Accelerations->Z;

    return MPU6050_OK;
}

static MPU6050_STATE_t MPU6050_CalibrateAccel(MPU6050_t *MPU6050)
{
    DataRaw_t Accelerations;
    int64_t SumX = 0, SumY = 0, SumZ = 0;
    uint16_t i;
    const uint16_t Samples = 200; // poprawny typ i wartość
    for(i = 0; i < Samples; i++)
    {
        if (MPU6050_ReadAccelerationRaw(MPU6050, &Accelerations) != MPU6050_OK)
        {
            HAL_Delay(2);
            return MPU6050_ERROR;
        }
        SumX += Accelerations.X;
        SumY += Accelerations.Y;
        SumZ += Accelerations.Z;
        HAL_Delay(1);
    }

    const float ScaleFactor = 16384.0f; // ±2g raw per 1g
    MPU6050->AccelOffset.X = (float)SumX / Samples;
    MPU6050->AccelOffset.Y = (float)SumY / Samples;
    // ustawiamy offset tak, aby po (raw - offset)/ScaleFactor = +1g dla Z
    MPU6050->AccelOffset.Z = ((float)SumZ / Samples) - ScaleFactor;

    return MPU6050_OK;
}

static MPU6050_STATE_t MPU6050_ReadGyroRaw(MPU6050_t *MPU6050, DataRaw_t *GyroRaw)
{
    uint8_t buf[6] = {0};
    if (HAL_I2C_Mem_Read(MPU6050->hi2c, (MPU6050->address)<<1, GYRO_XOUT_H, 1, buf, 6, MPU6050_TIMEOUT) != HAL_OK)
    {
        return MPU6050_ERROR;
    }

    GyroRaw->X = (int16_t)((buf[0] << 8) | buf[1]);
    GyroRaw->Y = (int16_t)((buf[2] << 8) | buf[3]);
    GyroRaw->Z = (int16_t)((buf[4] << 8) | buf[5]);

    return MPU6050_OK;
}

static MPU6050_STATE_t MPU6050_ReadGyro(MPU6050_t *MPU6050, Data_t *GyroCalculated)
{
    DataRaw_t Raw;
    MPU6050_ReadGyroRaw(MPU6050, &Raw);

    const float ScaleFactor = 131.0f; // ±250°/s

    //code to see gyro dryf
    MPU6050->GyroDryf.X = (float)((Raw.X) / ScaleFactor);
    MPU6050->GyroDryf.Y = (float)((Raw.Y) / ScaleFactor);
    MPU6050->GyroDryf.Z = (float)((Raw.Z) / ScaleFactor);

    //code with calibrated gyro data
    GyroCalculated->X = (float)((Raw.X - MPU6050->GyroOffset.X) / ScaleFactor);
    GyroCalculated->Y = (float)((Raw.Y - MPU6050->GyroOffset.Y) / ScaleFactor);
    GyroCalculated->Z = (float)((Raw.Z - MPU6050->GyroOffset.Z) / ScaleFactor);

    return MPU6050_OK;
}

static MPU6050_STATE_t MPU6050_CalibrateGyro(MPU6050_t *MPU6050)
{
    DataRaw_t Gyro;
    int64_t SumX = 0, SumY = 0, SumZ = 0;
    uint16_t i;
    const uint16_t Samples = 200;
    for(i = 0; i < Samples; i++)
    {
        if (MPU6050_ReadGyroRaw(MPU6050, &Gyro) != MPU6050_OK)
        {
            HAL_Delay(2);
            return MPU6050_ERROR;
        }
        SumX += Gyro.X;
        SumY += Gyro.Y;
        SumZ += Gyro.Z;
        HAL_Delay(1);
    }
    MPU6050->GyroOffset.X = (float)SumX / Samples;
    MPU6050->GyroOffset.Y = (float)SumY / Samples;
    MPU6050->GyroOffset.Z = (float)SumZ / Samples;

    return MPU6050_OK;
}
